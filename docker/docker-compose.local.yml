services:
  nginx:
    # Optional in local dev. Enable explicitly with: --profile nginx
    profiles: ["nginx"]
    ports:
      - "8080:80"  # Use port 8080 locally to avoid macOS port 80 conflicts
    volumes:
      # Override production config with local development config (no CSP headers)
      - ./nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf:ro
      # Keep other config files and snippets from base compose
      - ./nginx/conf.d/snippets:/etc/nginx/conf.d/snippets:ro
      - ./nginx/conf.d/tor-support.conf.template:/etc/nginx/conf.d/tor-support.conf.template:ro
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./logs/nginx:/var/log/nginx
      - ./nginx/error_pages:/usr/share/nginx/html/error_pages:ro
    networks:
      - bisq-support-network

  bisq2-api:
    platform: linux/amd64
    image: bisq2-api

  api:
    # Ensure entrypoint runs to drop privileges to bisq-support user (UID 1001)
    entrypoint: ["/entrypoint.sh"]
    volumes:
      # Mount the application code for hot-reloading
      - ../api/app:/app/app
      # Mount the data separately so its changes don't trigger reloads
      - ../api/data:/data
    environment:
      - ENVIRONMENT=development
      # Default uses the dockerized bisq2-api service.
      # To use a manually started host Bisq2 API, set:
      #   BISQ_API_URL=http://host.docker.internal:8090
      - BISQ_API_URL=${BISQ_API_URL:-http://bisq2-api:8090}
      - BISQ_API_AUTH_ENABLED=${BISQ_API_AUTH_ENABLED:-false}
      - BISQ_API_CLIENT_ID=${BISQ_API_CLIENT_ID:-}
      - BISQ_API_CLIENT_SECRET=${BISQ_API_CLIENT_SECRET:-}
      - BISQ_API_SESSION_ID=${BISQ_API_SESSION_ID:-}
      - BISQ_API_PAIRING_CODE_ID=${BISQ_API_PAIRING_CODE_ID:-}
      - BISQ_API_PAIRING_QR_FILE=${BISQ_API_PAIRING_QR_FILE:-}
      - BISQ_API_PAIRING_CLIENT_NAME=${BISQ_API_PAIRING_CLIENT_NAME:-bisq-support-agent}
      - BISQ_API_AUTH_STATE_FILE=${BISQ_API_AUTH_STATE_FILE:-bisq_api_auth.json}
      - DATA_DIR=/data # Point to the non-reloaded data directory
    # Linux compatibility for host access; Docker Desktop already provides host.docker.internal.
    extra_hosts:
      - "host.docker.internal:host-gateway"
    # Note: --loop asyncio disables uvloop to allow AISuite's MCP client to work
    # (nest_asyncio cannot patch uvloop, only standard asyncio event loops)
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload --reload-dir /app/app --loop asyncio
    ports:
      - "8000:8000"
    healthcheck:
      # Extend the startup period to allow for slow initial setup (e.g., embedding downloads)
      test: [ "CMD", "curl", "-f", "http://localhost:8000/health" ]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 180s

  web:
    build:
      context: ..
      dockerfile: docker/web/Dockerfile.dev
    command: ["npm", "run", "dev"]
    volumes:
      - ../web:/app
      - web_node_modules:/app/node_modules
    ports:
      - "3000:3000"
    environment:
      # Local dev defaults to direct API calls (nginx is optional/off by default).
      - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL:-http://localhost:8000}
      # Server-side requests from the web container to API container.
      - API_URL_INTERNAL=http://api:8000
      - NODE_ENV=development
      - NEXT_TELEMETRY_DISABLED=1
      - CHOKIDAR_USEPOLLING=true
    healthcheck:
      # Extended timeouts for local development - Next.js compilation can take 15-30s
      test: [ "CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/" ]
      interval: 30s
      timeout: 60s
      retries: 10
      start_period: 60s
    deploy:
      resources:
        limits:
          memory: 2G  # Next.js dev compilation needs more than 1GB
    # Base compose sets read_only=true for production hardening.
    # Disable it in local dev so Next.js can generate /app/.next manifests.
    read_only: false

networks:
  bisq-support-network:
    driver: bridge
